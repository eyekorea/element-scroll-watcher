{"version":3,"file":"element-scroll-watcher.esm.min.js","sources":["../src/element-scroll-watcher.js"],"sourcesContent":["/**\n * class ElementScrollWatcher\n * @author sanghyun jeung <eyekorea@cttd.co.kr>\n */\n\n/**\n * _x, _y 값을 체크하여 문자열인경우 유효한 값인지, 유효한 값이 아닌경우 px 값(Number)으로 리턴.\n * @param {String|Number} _x left|right|center or pixel number\n * @param {String|Number} _y top|bottom|middle or pixel number\n * @returns {Object} x, y string|number\n */\nfunction checkTargetPosXY(_x, _y){\n  const xPosReg = /left|right|center/g;\n  const yPosReg = /top|bottom|middle/g; \n  const x = (xPosReg.test(_x)) ? _x : parseInt(_x, 10);\n  const y = (yPosReg.test(_y)) ? _y : parseInt(_y, 10);\n  return {x, y};\n}\n\n/**\n * 난수를 리턴하는 함수.\n * @param {number} len\n * @returns {Number} len 의 값의 자릿수를 갖는 난수를 리턴\n */\nfunction uid(len) {\n  len = len || 7;\n  return Math.random()\n    .toString(35)\n    .substr(2, len);\n}\n\n/**\n * esw 제어를 위한 클래스\n * 감시 되는 엘리먼트 별로 해당 클래스가 생성됨.\n * @class\n */\nclass EswItem {\n  /**\n   * 클래스 생성시 감시되는 element 와 메인으로 실행되는 클래스 자신을 받음.\n   * @constructor EswItem\n   * @param {HTMLElement} element \n   * @param {ElementScrollWatcher} root \n   */\n  constructor(element, root){\n    this.id = uid(); // object 체크를 위한 id 난수\n    this.element = element;\n    this.element.dataset.eswId = this.id; \n\n    // element 의 개별 셋팅 값이 있는지 체크 하여 저장\n    this.datumPointX = (()=>{\n      if( element.dataset.eswCheckX ) {\n        return checkTargetPosXY(element.dataset.eswCheckX, 0).x;\n      } else {\n        return root.checkX;\n      };\n    })();\n\n    // element 의 개별 셋팅 y 값이 있는지 체크 하고 없으면 기본 셋팅값을 저장.\n    this.datumPointY = (()=>{\n      if( element.dataset.eswCheckY ) {\n        return checkTargetPosXY(0, element.dataset.eswCheckY).y;\n      } else {\n        return root.checkY;\n      };\n    })();\n    // element 의 개별 셋팅 delay 값이 있는지 체크 하고 없으면 기본 셋팅값을 적용.\n    this.activeTimer = (()=>{\n      if( element.dataset.eswDelay ) {\n        return parseInt(element.dataset.eswDelay, 10);\n      } else {\n        return root.option.activeDelay;\n      }\n    })();\n    this._isIntersecting = false; // 화면에 들어왔는지 유무\n    this.timer = null; // 타이머가 지정됨\n    this.activeFunction = root.option.active; // 활성화 되었을때 실행될 함수\n    this.deActiveFunction = root.option.deActive; // 비활성화 되었을때 실행될 함수\n    this.directFunction = root.option.direct; // 대기시간 없이 바로 실행될 함수\n  }\n\n  /**\n   * 화면안으로 들어오거나 나갔을때 해당 값을 셋팅 할 수 있음.\n   * 해당 값이 변경되면, 타이머를 초기화 하고 deActiveFunction 을 실행함.\n   * @param {boolean} value \n   */\n  set isIntersecting(value){\n    if( value !== this._isIntersecting ){\n      if( this.timer !== null ){\n        window.clearTimeout(this.timer);\n        this.timer = null;\n      }\n    }\n    if( !value ){\n      this.deActiveFunction && this.deActiveFunction(this.element);\n    }\n    this._isIntersecting = value;\n  }\n  \n  /**\n   * 엘리먼트 개별 기준값 을 대입한 값을 참고하여 화면기준으로 감시되는 엘리면트가 위치하는 Y 값의 백분율\n   * @returns {Number} \n   */\n  get percentY(){\n    const { element, datumPointY } = this;\n    const rect = element.getBoundingClientRect();\n    const pointY = (()=>{\n      if( typeof datumPointY === 'string' ) {\n        switch (datumPointY) {\n          case 'top':\n            return 0;\n          case 'bottom':\n            return rect.height;\n          default:\n            return rect.height / 2;\n        }\n      } else {\n        return datumPointY;\n      }\n    })();\n    const winHeight = window.innerHeight;\n    const y = rect.y + pointY;\n    const percentY = (winHeight - y) / winHeight * 100;\n    return percentY;\n  }\n\n  /**\n   * 엘리먼트 개별 기준값 을 대입한 값을 참고하여 화면기준으로 감시되는 엘리면트가 위치하는 X 값의 백분율\n   * @returns {Number} \n   */\n  // TODO: 개발 필요.\n  get percentX(){\n    const { element, datumPointX } = this;\n    const rect = element.getBoundingClientRect();\n    const pointX = (()=>{\n      if( typeof datumPointX === 'string' ) {\n        switch (datumPointX) {\n          case 'left':\n            return 0;\n          case 'right':\n            return rect.width;\n          default:\n            return rect.width / 2;\n        }\n      } else {\n        return datumPointX;\n      }\n    })();\n    const winWidth = window.innerWidth;\n    const x = rect.x + pointX;\n    const percentX = (winWidth - x) / winWidth * 100;\n    return percentX;\n  }\n\n  /**\n   * 타이머와 상관없이 진입시 실행되는 함수.\n   */\n  direct(){\n    if( this._isIntersecting ){\n      this.directFunction && this.directFunction(this.element);\n    }\n  }\n\n  /**\n   * 타이머를 활성화 하고, 함수 실행 준비 상태로 변경.\n   * _isIntersecting 이 true 인 경우 최종 activeFunction 를 실행.\n   * @method\n   */\n  active(){\n    const { activeTimer } = this;\n    if( this.timer === null ){\n      this.timer = window.setTimeout(()=>{\n        if( this._isIntersecting ){\n          this.activeFunction && this.activeFunction(this.element);\n        }\n      }, activeTimer);\n      this.direct();\n    }\n  }\n\n  /**\n   * _isIntersecting 값과 무관하게 강제로 함수 실행을 초기하고,\n   * deActiveFunction 을 실행함.\n   * @method\n   */\n  deActive(){\n    if( this.timer !== null ){\n      window.clearTimeout(this.timer);\n      this.timer = null;\n    }\n    this.deActiveFunction && this.deActiveFunction(this.element);\n  }\n}\n\n/**\n * string, nodeList, element 를 체크하여, [element] 로 리턴함.\n * @param {String|HTMLElement|NodeList} elements \n * @returns {Array} [... elements] \n */\nfunction elementsArray(elements){\n  if( typeof elements === 'string' ){\n    return Array.from(document.querySelectorAll(elements));\n  } else {\n    if( elements.length ) {\n      return Array.from(elements);\n    } else {\n      if( elements ) return [elements]\n    }\n  }\n}\n\n/**\n * ElementScrollWatcher 의 기본 setting 값\n * @namespace defaultSetting\n * @property {Window|HTMLElement} root - 스크롤 이벤트가 바인드 되는 영역.\n * @property {Number} activePercentY   - 진입 체크 시작 포인트 \n * @property {Number} deActivePercentY -  진입 체크 엔드 포인드\n * @property {Number} activePercentX\n * @property {Number} deActivePercentX\n * @property {Number} activeDelay      - 진입시 해당 시간 후 함수 실행됨.\n * @property {Number} threshold        - intersectionObserve 의 threshold \n * @property {null|function} direct    - 진입했을때 대기 없이 바로 실행 되는 callback\n * @property {null|function} active    - 진입했을때 실행될 callback \n * @property {null|function} deActive  - 나갔을때 실행될 callback\n * @property {null|function} scroll    - 스크롤 될때 실행될 callback\n * @property {boolean} init            - 최초 init 을 할지 옵션\n * @property {string|number} checkY    - top|middle|bottom|custom number(px),target 의 기준점.\n * @property {string|number} checkX    - left|center|right|custom number(px)\n */\nconst defaultSetting = {\n  root: null,\n  activePercentY: 60,\n  deActivePercentY : 90,\n  activePercentX: 0,\n  deActivePercentX : 100,\n  activeDelay: 1000,\n  threshold: 0.1,\n  direct: null,\n  active: null,\n  deActive: null,\n  scroll: null,\n  init: true,\n  checkY: 'top',\n  checkX: 'left'\n}\n\n/**\n * 메인 class.\n * 새로운 스크롤 감시자를 생성한다.\n * @class\n */\nexport default class ElementScrollWatcher {\n  /**\n   * @constructor\n   * @param {String|HTMLElement|HTMLCollection} elements String = selector ex) `.element` or `#id`\n   * @param {Ojbect} setting\n   * @param {Window|HTMLElement} setting.root - 스크롤 이벤트가 바인드 되는 영역.\n   * @param {Number} setting.activePercentY   - 진입 체크 시작 포인트 \n   * @param {Number} setting.deActivePercentY -  진입 체크 엔드 포인드\n   * @param {Number} setting.activePercentX\n   * @param {Number} setting.deActivePercentX\n   * @param {Number} setting.activeDelay     - 진입시 해당 시간 후 함수 실행됨.\n   * @param {Number} setting.threshold       - intersectionObserve 의 threshold \n   * @param {null|function} setting.direct   - 진입했을때 대기 없이 바로 실행 되는 callback\n   * @param {null|function} setting.active   - 진입했을때 실행될 callback \n   * @param {null|function} setting.deActive - 나갔을때 실행될 callback\n   * @param {null|function} setting.scroll   - 스크롤 될때 실행될 callback\n   * @param {boolean} setting.init           - 최초 init 을 할지 옵션\n   * @param {string|number} setting.checkY   - top|middle|bottom|custom number(px),target 의 기준점.\n   * @param {string|number} setting.checkX   - left|center|right|custom number(px)\n   */\n  constructor(elements, setting={}){\n    // set\n    const option = Object.assign({}, defaultSetting, setting);;\n    option.root = option.root === null ? window : option.root\n    const items = elementsArray(elements);\n    const checkItems = [];\n    const eswObject = {};\n    const XY = checkTargetPosXY(option.checkX, option.checkY);\n    const checkY = XY.y;\n    const checkX = XY.x;\n    const io = new IntersectionObserver(entries=>{ // IO 를 지정.\n      entries.forEach(entry => {\n        const target = entry.target;\n        const item = this.getEswObj(target);\n        item.esw.isIntersecting = entry.isIntersecting; // esw item 의 intersecting 값을 셋팅 한다.\n\n        // 화면에 들어오는 element 는 checkItems 에 넣고,\n        // 화면에서 나간 element 는 checkItems 에서 제거함.\n        // 스크롤시 loop 가 계속 돌게 되기 때문에 성능을 고려하여...\n        if( entry.isIntersecting ){\n          this.checkItems.push(target);\n        } else {\n          const index = this.checkItems.indexOf( target );\n          if( index >= 0 ){\n            this.checkItems.splice(index, 1);\n          }\n        }\n      });\n    });\n    \n    Object.assign(this, {\n      option,\n      items,\n      io,\n      checkItems,\n      checkY,\n      checkX,\n      eswObject,\n      isInit : false,\n      isDisable : false, // 비활성화 유무\n      boundMot: null // scroll event 를 저장함.\n    });\n    option.init && this.init();\n  }\n\n  /**\n   * element 의 dataset.eswId 값을 체크하여 object 를 리턴함.\n   * @param {element} element \n   * @returns {Object} HTMLElement, id, esw object\n   */\n  getEswObj(element){\n    const id = element.dataset.eswId;\n    const esw = this.eswObject[id];\n    return {element, id, esw};\n  }\n\n  // 스크롤시 실행함.\n  mot(){\n    if( this.isDisable ) return false;\n    const { checkItems , option } = this;\n    checkItems.forEach(element => {\n      const item = this.getEswObj(element);\n      const itemYPercent = item.esw.percentY;\n      const itemXPercent = item.esw.percentX;\n      const isIntersecting = item.esw._isIntersecting;\n\n      \n      const isActiveY = option.activePercentY < itemYPercent;\n      const isDeActiveY = option.deActivePercentY < itemYPercent;\n      const isActiveX = option.activePercentX < itemXPercent;\n      const isDeActiveX = option.deActivePercentX < itemXPercent;\n\n      if( isActiveY && isActiveX ){\n        if( isDeActiveY || isDeActiveX ) {\n          item.esw.deActive();\n        } else {\n          item.esw.active();\n        }\n      } else {\n        item.esw.deActive();\n      }\n\n      /**\n       * @namespace percent\n       * @property {Number} x - x축으로 이동된 양(백분율)\n       * @property {Number} y - y축으로 이동된 양(백분율)\n       */\n      const percent = {\n        x : itemXPercent, \n        y : itemYPercent,\n      }\n      option.scroll && option.scroll(element, percent, isIntersecting);\n    });\n  }\n\n  init(){\n    const { items, io, option, mot } = this;\n    this.boundMot = mot.bind(this);\n    if( !this.isInit ) {\n      option.root.addEventListener('scroll', this.boundMot, false);\n    }\n\n    items.forEach(element => {\n      if( !element.dataset.eswInit ){\n        const esw = new EswItem(element, this);\n        this.eswObject[esw.id] = esw;\n        io.observe(element, option.threshold);\n        element.dataset.eswInit = 'init'\n      }\n    })\n    this.isInit = true;\n    window.addEventListener('load', ()=>{\n      this.mot();  \n    });\n    this.mot();\n  }\n\n  /**\n   * 동적으로 element 가 생성 된 경우 사용.\n   * @param {HTMLCollection|HTMLElement|String} elements String = selector ex) `.element` or `#id`\n   */\n  update(elements){\n    const addItems = elementsArray(elements);\n    this.items = this.items.concat(addItems);\n    this.init();\n  }\n  disable(){\n    this.isDisable = true;\n  }\n  enable(){\n    this.isDisable = false;\n  }\n  destroy(){\n    const { items, io, option } = this;\n    option.root.removeEventListener('scroll', this.boundMot, false);\n    items.forEach(element => {\n      io.unobserve(element);\n      delete element.dataset.eswId;\n      delete element.dataset.eswInit;\n    });\n\n    delete this.boundMot;\n    delete this.io;\n    delete this.items;\n    delete this.checkItems;\n    delete this.checkY;\n    delete this.checkX;\n    delete this.eswObject;\n    delete this.isInit;\n    delete this.isDisable;\n    delete this.option;\n    delete this;\n  }\n}"],"names":["checkTargetPosXY","_x","_y","x","test","parseInt","y","EswItem","[object Object]","element","root","len","this","id","Math","random","toString","substr","dataset","eswId","datumPointX","eswCheckX","checkX","datumPointY","eswCheckY","checkY","activeTimer","eswDelay","option","activeDelay","_isIntersecting","timer","activeFunction","active","deActiveFunction","deActive","directFunction","direct","isIntersecting","value","window","clearTimeout","percentY","rect","getBoundingClientRect","pointY","height","winHeight","innerHeight","percentX","pointX","width","winWidth","innerWidth","setTimeout","elementsArray","elements","Array","from","document","querySelectorAll","length","defaultSetting","activePercentY","deActivePercentY","activePercentX","deActivePercentX","threshold","scroll","init","setting","Object","assign","items","XY","io","IntersectionObserver","entries","forEach","entry","target","getEswObj","esw","checkItems","push","index","indexOf","splice","eswObject","isInit","isDisable","boundMot","item","itemYPercent","itemXPercent","isActiveY","isDeActiveY","isActiveX","isDeActiveX","percent","mot","bind","addEventListener","eswInit","observe","addItems","concat","removeEventListener","unobserve"],"mappings":"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"}