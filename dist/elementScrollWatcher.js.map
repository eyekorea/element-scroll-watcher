{"version":3,"sources":["elementScrollWatcher.js"],"names":["ElementScrollWatcher","checkTargetPosXY","_x","_y","x","test","parseInt","y","uid","len","Math","random","toString","substr","ESW_ITEM","element","root","id","dataset","datumPointX","checkX","datumPointY","checkY","activeTimer","option","activeDelay","isIntersecting","timer","activeFunction","active","deActiveFunction","deActive","window","setTimeout","clearTimeout","value","rect","getBoundingClientRect","pointY","height","winHeight","innerHeight","percentY","pointX","winWidth","innerWidth","percentX","elementsArray","elements","Array","from","document","querySelectorAll","length","ESW","set","items","XY","io","IntersectionObserver","entries","forEach","entry","target","getEswObj","esw","setIntersecting","checkItems","push","index","indexOf","splice","Object","assign","eswObject","isInit","init","item","itemYPercent","getPercentY","activePercentY","deActivePercentY","addEventListener","mot","observe","threshold","addItems","concat","defaultSetting","activePercentX","deActivePercentX","setting"],"mappings":"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","file":"elementScrollWatcher.js","sourceRoot":"../src","sourcesContent":["/**\n * \n * @param {*} _x /left|right|center/ or pixel number\n * @param {*} _y /top|bottom|middle/ or pixel number\n * _x, _y 값을 체크하여 문자열인경우 유효한 값인지, 유효한 값이 아닌경우 px 값으로 리턴.\n */\nfunction checkTargetPosXY(_x, _y){\n  const xPosReg = /left|right|center/g;\n  const yPosReg = /top|bottom|middle/g; \n  const x = (xPosReg.test(_x)) ? _x : parseInt(_x, 10);\n  const y = (yPosReg.test(_y)) ? _y : parseInt(_y, 10);\n  return {x, y};\n}\n\n/**\n *\n * @param {number} len\n * number 값의 자릿수를 갖는 난수를 리턴\n */\nexport function uid(len) {\n  len = len || 7;\n  return Math.random()\n    .toString(35)\n    .substr(2, len);\n}\n\n/**\n * esw 제어를 위한 클래스\n * 감시 되는 엘리먼트 별로 해당 클래스가 생성됨.\n */\nclass ESW_ITEM {\n  constructor(element, root){\n    this.id = uid(); // object 체크를 위한 id 난수\n    this.element = element;\n    this.element.dataset['eswId'] = this.id; \n\n    // element 의 개별 셋팅 값이 있는지 체크 하여 저장\n    this.datumPointX = (()=>{\n      if( element.dataset['eswCheckX'] ) {\n        return checkTargetPosXY(element.dataset['eswCheckX'], 0).x;\n      } else {\n        return root.checkX;\n      };\n    })();\n\n    // element 의 개별 셋팅 값이 있는지 체크 하여 저장\n    this.datumPointY = (()=>{\n      if( element.dataset['eswCheckX'] ) {\n        return checkTargetPosXY(0, element.dataset['eswCheckY']).y;\n      } else {\n        return root.checkY;\n      };\n    })();\n\n    this.activeTimer = root.option.activeDelay; // 딜레이시간\n    this.isIntersecting = false; // 화면에 들어왔는지 유무\n    this.timer = null; // 타이머가 지정됨\n    this.activeFunction = root.option.active; // 활성화 되었을때 실행될 함수\n    this.deActiveFunction = root.option.deActive; // 비활성화 되었을때 실행될 함수\n  }\n\n  /**\n   * @param {boolean} value\n   * 화면안으로 들어오거나 나갔을때 해당 값을 셋팅 할 수 있음.\n   * 들어왔을 경우 true\n   * 나갔을 경우 false\n   * 해당 값이 변경되면, 타이머를 초기화 하고 deActiveFunction 을 실행함.\n   */\n  set setIntersecting(value){\n    if( value !== this.isIntersecting ){\n      if( this.timer !== null ){\n        window.clearTimeout(this.timer);\n        this.timer = null;\n      }\n    }\n    if( !value ){\n      this.deActiveFunction(this.element);\n    }\n    this.isIntersecting = value;\n  }\n  \n  // 화면을 기준으로 element 가 몇퍼센트에 위치하는지 리턴함.\n  // 엘리먼트 개별 기준값 을 대입한 값.\n  get getPercentY(){\n    const { element, datumPointY } = this;\n    const rect = element.getBoundingClientRect();\n    const pointY = (()=>{\n      if( typeof datumPointY === 'string' ) {\n        switch (datumPointY) {\n          case 'top':\n            return 0;\n          case 'bottom':\n            return rect.height;\n          default:\n            return rect.height / 2;\n        }\n      } else {\n        return datumPointY;\n      }\n    })();\n    const winHeight = window.innerHeight;\n    const y = rect.y + pointY;\n    const percentY = (winHeight - y) / winHeight * 100;\n    return percentY;\n  }\n\n  // 화면을 기준으로 element 가 몇퍼센트에 위치하는지 리턴함.\n  // 엘리먼트 개별 기준값 을 대입한 값.\n  get getPercentX(){\n    const { element, datumPointX } = this;\n    const rect = element.getBoundingClientRect();\n    const pointX = (()=>{\n      if( typeof datumPointX === 'string' ) {\n        switch (datumPointX) {\n          case 'top':\n            return 0;\n          case 'bottom':\n            return rect.height;\n          default:\n            return rect.height / 2;\n        }\n      } else {\n        return datumPointX;\n      }\n    })();\n    const winWidth = window.innerWidth;\n    const x = rect.x + pointX;\n    const percentX = (winWidth - x) / winWidth * 100;\n    return percentX;\n  }\n\n  // 타이머를 활성화 하고, 함수 실행 준비 상태로 변경.\n  // isIntersecting 이 true 인 경우 최종 activeFunction 를 실행.\n  active(){\n    if( this.timer === null ){\n      this.timer = window.setTimeout(()=>{\n        if( this.isIntersecting ){\n          this.activeFunction(this.element);\n        }\n      }, this.activeTimer);\n    }\n  }\n\n  // isIntersecting 값과 무관하게 강제로 함수 실행을 초기하고,\n  // deActiveFunction 을 실행함.\n  deActive(){\n    if( this.timer !== null ){\n      window.clearTimeout(this.timer);\n      this.timer = null;\n    }\n    this.deActiveFunction(this.element);\n  }\n}\n\n/**\n * \n * @param {*} elements \n * string, nodeList, element 를 체크하여, [element] 로 리턴함.\n */\nfunction elementsArray(elements){\n  if( typeof elements === 'string' ){\n    return Array.from(document.querySelectorAll(elements));\n  } else {\n    if( elements.length ) {\n      return Array.from(elements);\n    } else {\n      if( elements ) return [elements]\n    }\n  }\n}\n\n\n\nclass ESW {\n  constructor(elements, set){\n    // set\n    const option = set;\n    option.root = set.root === null ? window : set.root\n    const items = elementsArray(elements);\n    const checkItems = [];\n    const eswObject = {};\n    const XY = checkTargetPosXY(set.checkX, set.checkY);\n    const checkY = XY.y;\n    const checkX = XY.x;\n    const io = new IntersectionObserver(entries=>{ // IO 를 지정.\n      entries.forEach(entry => {\n        const target = entry.target;\n        const item = this.getEswObj(target);\n        item.esw.setIntersecting = entry.isIntersecting; // esw item 의 intersecting 값을 셋팅 한다.\n\n        // 화면에 들어오는 element 는 checkItems 에 넣고,\n        // 화면에서 나간 element 는 checkItems 에서 제거함.\n        // 스크롤시 loop 가 계속 돌게 되기 때문에 성능을 고려하여...\n        if( entry.isIntersecting ){\n          this.checkItems.push(target);\n        } else {\n          const index = this.checkItems.indexOf( target );\n          if( index >= 0 ){\n            this.checkItems.splice(index, 1);\n          }\n        }\n      });\n    });\n    \n    Object.assign(this, {\n      option,\n      items,\n      io,\n      checkItems,\n      checkY,\n      checkX,\n      eswObject,\n      isInit : false\n    });\n    option.init && this.init();\n  }\n\n  /**\n   * \n   * @param {element} element \n   * element 의 dataset.eswId 값을 체크하여 object 를 리턴함.\n   * 없을 경우의 수는 없다....\n   */\n  getEswObj(element){\n    const id = element.dataset['eswId'];\n    const esw = this.eswObject[id];\n    return {element, id, esw};\n  }\n\n  // 스크롤시 실행함.\n  mot(){\n    const { checkItems , option } = this;\n    checkItems.forEach(element => {\n      const item = this.getEswObj(element);\n      const itemYPercent = item.esw.getPercentY;\n      \n      if( option.activePercentY < itemYPercent ){\n        if(option.deActivePercentY < itemYPercent ) {\n          item.esw.deActive();\n        } else {\n          item.esw.active();\n        }\n      } else {\n        item.esw.deActive();\n      }\n    });\n  }\n\n  init(){\n    const { items, io, option } = this;\n    if( !this.isInit ) {\n      option.root.addEventListener('scroll', ()=>{\n        this.mot();\n      });\n    }\n\n    items.forEach(element => {\n      if( !element.dataset['eswInit'] ){\n        const esw = new ESW_ITEM(element, this);\n        this.eswObject[esw.id] = esw;\n        io.observe(element, option.threshold);\n        element.dataset['eswInit'] = 'init'\n      }\n    })\n    this.isInit = true;\n    window.addEventListener('load', ()=>{\n      this.mot();  \n    });\n    this.mot();\n  }\n\n  // 동적으로 element 가 생성 된 경우 사용.\n  update(elements){\n    const addItems = elementsArray(elements);\n    this.items = this.items.concat(addItems);\n    this.init();\n  }\n  disable(){\n    \n  }\n  enable(){\n\n  }\n  destroyed(){\n    \n  }\n}\n\nconst defaultSetting = {\n  root: null, // scroll event bind element\n  activePercentY: 60, // 진입 체크 시작 포인트 \n  deActivePercentY : 90, // 진입 체크 엔드 포인드\n  activePercentX: 0,\n  deActivePercentX : 100,\n  activeDelay: 1000, // 진입시 해당 시간 후 함수 실행됨.\n  threshold: 0.1, // intersectionObserve 의 threshold \n  active: null, // 진입했을때 실행될 callback \n  deActive: null, // 나갔을때 실행될 callback\n  init: true, // 최초 init 을 할지 옵션\n  checkY: 'top', // top, middle, bottom, custom number(px) , target 의 기준점.\n  checkX: 'left' // left, center, right, custom number(px)\n}\n\nfunction ElementScrollWatcher(elements, setting={}){\n  const set = Object.assign({}, defaultSetting, setting);\n  return new ESW(elements, set);\n}\n\nexport default ElementScrollWatcher;"]}